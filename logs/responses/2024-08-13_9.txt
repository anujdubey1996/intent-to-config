
Create a Kubernetes deployment workload configuration file for a Java microservice running on port 8080.

Here's a basic example of a Kubernetes Deployment configuration file for a Java microservice named `my-service` that listens on port `8080`. The example assumes that the Docker image for the service is available in a registry under the tag `my-registry/my-service:v1`.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
  labels:
    app: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: my-service
        image: my-registry/my-service:v1
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ClusterIP
  selector:
    app: my-service
  ports:
  - port: 80
    targetPort: 8080
```

In this example:

- `replicas: 3` means that we want three instances of the deployment to run.
- The `selector` defines a label selector that targets the pods we want to scale, manage, and select for other commands. The label should be the same as in the `labels` field of the container.
- The `template` defines the specifications for the pods that will make up the deployment.
- The `spec.containers.ports` section defines the container port that the service listens on, in this case `8080`.
- The `spec.service` section creates a ClusterIP service, a type that allows communication within the cluster. The `selector` matches the labels defined in the deployment (`app: my-service`), and `port : 80` and `targetPort : 8080` define the external and internal ports, respectively.